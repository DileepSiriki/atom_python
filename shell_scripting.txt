
BASIC LINUX COMMANDS & USAGE :
======================================

1. help :  a. command --help  -> help is a bash built-in, providing help for bash commands only.
           b. man command    -> A little less descriptive than info but straight to point .
           c. info command   -> describe all about the command in detail. Its like lots and lots of pages of information will be there for a single command.
           d. man command | less

2. more -> When the text passed to it is too large to fit on one screen, it pages it. You can scroll down but not up.
           press enter or spacebar to navigate and q to exit.
           more /path/to/logile.txt
           more -10 /path/.. to set number of lines a page should contain
           more +10 /path/... to start from a specific line (here 10)
           cat /path/to/logfilr.txt | more
           ls --help | more

3. less -> you can scroll both up and down .
          less /path/... -> now enter /<string> to highlight the string needed.
          less -N -> display line numbers (not available in more )
          The main difference between more and less is that less command is faster because it does not load the entire file at once and allows navigation though file using page up/down keys

4. cat  -> textfile.txt
           cat > textfile.txt -> opens a file to write content . press ctrl+D to save and exit
                              -> if you do it to an already existing file , prevous contents will be deleted .
           cat textfile.txt -> opens a file

           The touch command is a standard command used in UNIX/Linux operating system which is used to create, change and modify timestamps of a file.
           Basically, there are two different commands to create a file in the Linux system which is as follows:
           cat command: It is used to create the file with content.
           touch command: It is used to create a file without any content. The file created using touch command is empty. This command can be used when the user doesn’t have data to store at the time of file creation.

cat command: It is used to create the file with content.
touch command: It is used to create a file without any content. The file created using touch command is empty. This command can be used when the user doesn’t have data to store at the time of file creation.


5. echo  ->  echo <string> -> display string on screen
             echo $var -> display value of variable if any
             echo <text> > textfile ->remove old contents in textfile and write <text> to it .
             echo <text> >> textfile -> append <text> to the textfile .
             echo * is is similar to ls command

INODE :  https://helpdeskgeek.com/linux-tips/what-are-inodes-in-linux-and-how-are-they-used/
An inode is a data structure that stores various information about a file in Linux, such as the access mode (read, write, execute permissions), ownership, file type, file size, group, number of links, etc. Each inode is identified by an integer number. An inode is assigned to a file when it is created .

6. ls ->    List files with colour schemes (blue to folders , black to files etc;)
            ls -R -> Recursive list , to list files even inside a directory .
            ls -a || la --all -> list files starting with a "."
            ls -l -> use vertical listing
            ls -i -> show the inodes
            ls -s -> print size allocated
            ls -S -> sort by size and print
            ls by default sorts by name , do "ls --sort=word -opt"
            ls -l | sort and ls -l | sort -r to sort in reverse

            ls -al -> detailed list of files and permissions , storage etc;
            drwxr-xr-x                      7               esrkdlp           rnd             4096         Jun 11  2019       workspace
            [filetype-permissions] - [# od hardlinks] - [Owner-Creator] - [Owber-group] - [Size in bytes] - [Date-Time] - [Name of file/dir]
            " - " -> file
            " d " -> directory
            " c " -> character files (Device files that are not files but have file like access to hardware.)


7. cd -> Chnage to a directory

8. pwd -> Present working directory

9. mkdir -> Make a directory
            mkdir abc     -> create a dir in current directory
            mkdir /test/abc     -> create a directory in /test directory
            mkdir dir1 dir2 dir3 -> create multiple directories at a time
            rmdir abc     -> removes a directory


10. cp -> cp stands for copy. This command is used to copy files or group of files or directory. It creates an exact image of a file on a disk with different file             name. copies each source file to the destination directory with the same name, created if not existed but if already existed then it will be overwritten,           so be careful !!.
          cp Src_file Dest_file
          cp Src_file1 Src_file2 Src_file3 Dest_directory
              (For this case last argument must be a directory name. For the above command to work, Dest_directory must exist because cp command won’t create it.)
          cp -R Src_directory Dest_directory
              (cp behavior depend upon whether Dest_directory is exist or not.
              If the Dest_directory doesn’t exist, cp creates it and copies content of Src_directory recursively as it is.
              But if Dest_directory exists then copy of Src_directory becomes sub-directory under Dest_directory)
          cp -i -> interactive (asks confirmation)
          cp -f -> forcbly copy
          cp -b -> create a backup of destination  before copying
          cp -n -> To not overwrite an existing filr

          IF [-i -n -f] ALL THREE ARGUMENTS ARE PRESENT , THE FINAL OPTIONS TAKES PRESIDENCE.

11. mv -> mv stands for move. mv is used to move one or more files or directories from one place to another in file system like UNIX. It has two distinct functions:
          - It rename a file or folder/directory .
          - It moves group of files to different directory.
          If the destination file doesn’t exist, it will be created.
          If the destination file exist, then it will be overwrite and the source file will be deleted. By default, mv doesn’t prompt for overwriting So be careful
          SIMILAR OPTIONS TO cp COMMAND.

12. ln ->
        HARD/SOFT links : https://ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/
        A symbolic or soft link is an actual link to the original file, whereas a hard link is a mirror copy of the original file. If you delete the original file,         the soft link has no value, because it points to a non-existent file. But in the case of hard link, it is entirely opposite. Even if you delete the original         file, the hard link will still has the data of the original file. Because hard link acts as a mirror copy of the original file. A link in UNIX is a pointer         to a file. Creating links is a kind of shortcuts to access a file. Links allow more than one file name to refer to the same file, elsewhere.

        There are two types of links  :
         1. Soft Link or Symbolic links -> Symbolic links are not updated (they merely contain a string which is the pathname of its target)
                $ ln  [original filename] [link name]
                  can cross the file system,
                  allows you to link between directories,
                  has different inode number and file permissions than original file,
                  permissions will not be updated,
                  has only the path of the original file, not the contents.

         2. Hard Links -> hard links always refer to the source, even if moved or removed
                $ ln  -s [original filename] [link name]
                  can't cross the file system boundaries (i.e. A hardlink can only work on the same filesystem),
                  can't link directories,
                  has the same inode number and permissions of original file,
                  permissions will be updated if we change the permissions of source file,

        esekilxv8818 [15:15] [/home/esrkdlp] -> mkdir links
        esekilxv8818 [15:15] [/home/esrkdlp] -> cd links
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> echo "sample text" > abc.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls
        abc.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ln -s abc.txt efg.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls
        abc.txt  efg.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> cat abc.txt
        sample text
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> cat efg.txt
        sample text
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls -lia
        total 16
        2990710331 drwxr-xr-x  2 esrkdlp rnd  4096 Nov 19 15:16 .
        3028884948 drwxr-xr-x 74 esrkdlp rnd 12288 Nov 19 15:15 ..
        2990710332 -rw-r--r--  1 esrkdlp rnd    12 Nov 19 15:16 abc.txt
        2990710333 lrwxrwxrwx  1 esrkdlp rnd     7 Nov 19 15:16 efg.txt -> abc.txt
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> rm abc
        abc.txt  efg.txt@
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> rm abc.txt
        rm: remove regular file `abc.txt'? y
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> ls
        efg.txt
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> cat efg.txt
        cat: efg.txt: No such file or directory

Do a similar steps for hardlinks checking.If you copy a file, it will just duplicate the content. So if you modify the content of a one file (either original or hard link), it has no effect on the other one. However if you create a hard link to a file and change the content of either of the files, the change will be be seen on both.

13. sort -> SORT command is used to sort a file, arranging the records in a particular order.
            Lines starting with a number will appear before lines starting with a letter.
            Lines starting with a letter that appears earlier in the alphabet will appear before lines starting with a letter that appears later in the alphabet.
            Lines starting with a lowercase letter will appear before lines starting with the same letter in uppercase.
            sort abc.txt
            sort -o abc.txt def.txt ->send the output to destination def.txt
            sort -r abc.txt -> sort in reverse order
            sort -c abc.txt -> check if file is sorted
            sort -u abc.txt -> sort and remoce duplicates
            sort -n abc.txt -> numerical sort
            sort -k xn abc.txt -> sort using the column number x (useful for tables)


14. rm ->  rm stands for remove here. rm command is used to remove objects such as files, directories, symbolic links and so on from the file system like UNIX. To be more precise, rm removes references to objects from the filesystem, where those objects might have had multiple references (for example, a file with two different names). By default, it does not remove directories.

            rm file1 file2
            rm -i file -> interactive remove
            rm -f file -> forece remove
            rm -r file -> recursive remove
            rm -rf dir -> recursive remove directory

15. chmod ->  chmod {u|g|o|a} {+|-|=} {r|w|x} {filename}
                  drwxr-xr-x  -> [type][(owner)(group)(others)]
                  WHO   ###    u -> User who owns the file ; g -> Group file owner  ;  o -> User classified as other ;  a -> All of above (u+g+o)
                  WHAT  ###    + -> Set permission         ; - -> Remove permission ;  = -> set and remove others
                  WHICH ###    r -> Read permission        ; w -> Write permission  ;  x -> Execute permission

                  0: (000) No permission.
                  1: (001) Execute permission.
                  2: (010) Write permission.
                  3: (011) Write and execute permissions.
                  4: (100) Read permission.
                  5: (101) Read and execute permissions.
                  6: (110) Read and write permissions.
                  7: (111) Read, write, and execute permissions.

              1. chmod u=rw,og=r new_file.txt (wipe out previous and set)
              2. chmod a+x new_script.sh  (add an extra. a+x is similar to +x )
              3. chmod -R o-r *.page (for subdirectories and files ending in .page)
              4. chmod 664 *.page

16. sudo ->  You only need root/sudo privileges, only if the command involves files or directories not owned by the user or group running the commands
             By default, the password you entered for sudo is retained for 15 minutes per terminal. This eliminates the need of entering the password time and again
             Sudo program allows regular users to run programs with the security privileges of the superuser or root.
             Sudo maintains a log of each command run. System administrators can trackback the person responsible for undesirable changes in the system.

17. history ->  To fetch the history of typed in commands.

18. clear   ->  Clears the screen and gives a clean window.

19. apt-get ->  ADVANCED PACKAGING TOOL
                In Linux/UNIX, installation files are distributed as packages. But the package contains only the program itself.
                Any dependent components will have to be installed separately which are usually available as packages themselves.
                Its main task is to retrieve the information and packages from the authenticated sources for installation, upgrade and removal of packages along with their dependencies.
                sudo apt-get update -> update all packages installed in our system.

                update  : This command is used to synchronize the package index files from their sources again. You need to perform an update before you upgrade or dist-upgrade.
                          apt-get update
                upgrade : This command is used to install the latest versions of the packages currently installed on the user’s system from the sources enumerated in /etc/apt/sources.list. The installed packages which have new packages available are retrieved and installed
                          apt-get upgrade
                install : This command is used to install or upgrade packages. It is followed by one or more package names the user wishes to install. All the dependencies of the desired packages will also be retrieved and installed.
                          apt-get install [...PACKAGES]
                remove  : This is similar to install, with the difference being that it removes the packages instead of installing. It does not remove any configuration files created by the package.
                          apt-get remove [...PACKAGES]

20. wc : It is used to find out number of lines, number of words count, byte and characters count in the files specified in the file arguments.
                $ wc state.txt capital.txt
                5   7  63 state.txt
                5   5  45 capital.txt
                10  12 108 total

21. who am i ## whoami ## who: To show the user information .
                who am i gives more info than whoami . Also the date and time is printed .
                who is used to show who is logged in at the moment . gives multiple names

                Other commands include -> users , who , w

22. Head :  print the top N number of data of the given input. By default, it prints the first 10 lines of the specified files. If more than one file name is provided then data from each file is preceded by its file name.
            head -n 5 state.txt -> print n lines
            head -c 6 state.txt -> print n bytes
            head -n 20 state.txt | tail -10  -> Print line between M and N lines
            head -n -15  -> cut the last 15 lines

23. Tail : print the last N number of data of the given input. By default it prints the last 10 lines of the specified files. If more than one file name is provided then data from each file is precedes by its file name.
           similar options as head command.

24. grep : The grep filter searches a file for a particular pattern of characters, and displays all lines that contain that pattern
           grep -i regex file -> case insesitive searches
           grep -c regex file -> count of matches
           grep -w regex file -> search the whole word instead of a regular expression
           grep -n regex file -> show line numbers
           grep -v regex file -> lines not matching with regex

25. diff and cmp :

26. bg :

27. ps and kill and jobs : PS stand for PROCESS STATES similar to task manager .
                           https://www.linux.com/training-tutorials/and-ampersand-and-linux/
                           https://www.guru99.com/managing-processes-in-linux.html
          jobs shows you the processes running in your current terminal, whether be it in the background or foreground. It also shows you a number associated with each job

          The fg brings a job from the background to the foreground so you can interact with it. You tell fg which process you want to bring to the foreground with a percentage symbol (%) followed by the number associated with the job that jobs gave you:

              $ fg %1 # brings the cp job to the foreground
              cp -i -R original/dir/* backup/dir/

          The bg command pushes a job to the background and resumes it again if it was paused:

              $ bg %1
              [1]+ cp -i -R original/dir/* backup/dir/ &

          In the foreground process , no other commands can be run because the prompt will be not available.
          But a background process started with & will wait for a keyboard input .

          You can get the PID of any running process with the ps (short for processes) command. So, using

              ps | grep cp

              kill -s STOP 14444  -> you can stop the background copying
              kill -s CONT 14444  -> To start the paused process again, you can use the CONT signal
              pgrep = ps + pgrep

           *** top command can be used to list the curent running processes in linux .
           top allows you display of process statistics continuously until stopped vs. ps which gives you a single snapshot.
           top enables you to see your processes ordered by the amount of processor power they use.
           ps enables you to see all your processes, or just the processes used by certain users, for example root or yourself.

           nice command can be used to start a process with a given priority . (b/w 1 to 20)
           renice can be used to change priority of an already running process  .
           df used to report free disk spaces
           free used to report used and free RAM .


28. which : prints the executable path .

29. uniq : The uniq command in Linux is a command line utility that reports or filters out the repeated lines in a file.
             In simple words, uniq is the tool that helps to detect the adjacent duplicate lines and also deletes the duplicate lines.
             uniq filters out the adjacent matching lines from the input file(that is required as an argument) and writes the filtered data to the output file .

             Note: uniq isn’t able to detect the duplicate lines unless they are adjacent.
             The content in the file must be therefore sorted before using uniq or you can simply use sort -u instead f uniq.

30. SOURCE : source is a shell built-in command which is used to read and execute the content of a file(generally set of commands), passed as an argument in the current shell script. The command after taking the content of the specified files passes it to the TCL interpreter as a text script which then gets executed. If any arguments are supplied, they become the positional parameters when filename is executed. Otherwise, the positional parameters remain unchanged. The entries in $PATH are used to find the directory containing FILENAME, however if the file is not present in $PATH it will search the file in the current directory

31. find : Find command is used to search and locate the list of files and directories based on conditions you specify for files that match the arguments.
           Find can be used in a variety of conditions like you can find files by permissions, users, groups, file type, date, size, and other possible criteria.
           find <path> <options> <file/dir>
           find /home -iname tecmint.txt (i for ignorecase)
           find / -type d -name Tecmint (search for directory)
           find . -type f -name tecmint.php (search for file)
           


31. df , free  :
32. APT-GET , UPGRADE ETC;

========================================================================
========================================================================


SHELL SCRIPTING :
=======================

SET Vs ENV :
------------
set is a shell command to set the value of a shell attribute variable; these are internal variables used by the shell.
env is a program that runs another program with modified environment variables.
The major difference is that the env command will never modify the shell's own environment (only that of the child process), while set will. Set can also change settings like brace expansion within the shell.
You might also want to look at export, which changes the environment variables for all future commands.

environmental variables are dynamic values that effect processes on a computer .
create using SET and delete using UNSET .


KERNAL :
----------
Kernel is hart of an O/S say linux .. It manages resource of Linux O/S. Resources means facilities available in Linux.
It is reasonable for communication between Hardware and Software.
A system may have many shells but only one kernal .
For eg. Facility to store data, print data on printer, memory, file management etc . Kernel decides who will use this resource, for how long and when.
It runs your programs (or set up to execute binary files) It's Memory resident portion of Linux. It performance following task :-
● I/O management
● Process management
● Device management
● File management
● Memory management

|---------------------------------------------------------------------|-------------------------|
|                            ===============================          |                         |
|    --------              ||   --------   ---    -------   ||        |        ---------        |
|  | HARDWARE |   <<-->>   ||  | KERNAL | | OS | | SHELL |  ||      <<-->    || TERMINAL |      |
|    --------              ||   --------   ---    -------   ||        |        ----------       |
|                            ===============================          |             ^           |
|---------------------------------------------------------------------|----------   |  ---------|
|                    Applications , cd , ls , grep , compilers etc ;                V           |    <<-->>  | USER-1 |
|-----------------------------------------------------------------------------------------------|    <<-->>  | USER-2 |



LINUX is a KERNAL , not an OS . Its a clone of UNIX KERNAL .
LINUX KERNAL + GNU SOFTWARE = OPERATING SYSTEM (say Ubuntu / Redhat)
Everything in LINUX is a file even a printer and a mouse .

UNIX OS  : HP-UX , IBM AIX , SUN SOLARIS , MAC OS X .(Paid services)
LINUX OS : REDHAT , DEBIAN , UBUNTU. (Free and open source but some priced versions are available )


POSIX :
-------
Portable Operating System interface is a family of standards specified by IEEE for maintaining compatibility between operating systems.


SHELL : ( a macro processor that executes commands) :
-----------------------------------------------------
In computing, a shell is a computer program which exposes an operating system's services to a human user or other program .
In general, operating system shells use either a command-line interface (CLI) or graphical user interface (GUI), depending on a computer's role and particular operation
It is named a shell because it is the outermost layer around the operating system.
A command-line interface (CLI) is an operating system shell that uses alphanumeric characters typed on a keyboard to provide instructions and data to the operating system.
Including various services to their users, including file management, process management (running and terminating applications), batch processing, and operating system monitoring and configuration.
MICROSOFT WINDOWS -> Windows Shell and Power shell
LINUX/UNIX  -> Bourne again Shell (bash) , unix shell , Bourne shell (sh)


UNINX SHELL :
-------------
A Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts.[
A Unix shell is both a command interpreter and a programming language.
As a command interpreter, the shell provides the user interface to the rich set of gnu utilities. The programming language features allow these utilities to be combined
Unix shells provide filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration.

Computer understand the language of 0's and 1's called binary language,
In early days of computing, instruction are provided using binary language, which is difficult for all of us, to read and write.
So in O/s there is special program called Shell. Shell accepts your instruction or commands in English and translate it into computers native binary language.

   --------------------        ------------       ---------------------------       -------
  | command/shell_script | -> | Linux shell | -> | Binary equalent of command | -> | KERNAL |
   --------------------        ------------       ---------------------------       -------

  $ls ; $date -> BASH -> 10001101 -> LINUX KERNAL

  OS = KERNAL + SHELL [KERNAL handles everything and shell helps us interact with it .]


SHELL SCRIPTING :	(called BATCH files in MS-DOS) ;
--------------------------------------------------
A shell script is a computer program designed to be run by the Unix shell, a command-line interpreter
The biggest advantage of writing a shell script is that the commands and syntax are exactly the same as those directly entered at the command-line. The programmer does not have to switch to a totally different syntax, as they would if the script were written in a different language, or if a compiled language were used.
Disadvantages -> rm -rf */ and rm -rf * / (deletes everything including root ) and also that commands vary by  a single word -> cd cc df etc;


PROCESS : https://www.guru99.com/managing-processes-in-linux.html
----------
Process is any kind of program or task carried out by your PC.
For e.g. $ ls -lR , is command or a request to list files in a directory and all subdirectory in your current  directory. It is a process.
A process is program (command given by user) to perform some Job. In Linux when you start process, it gives a number (called PID or process-id), PID starts from 0 to 65535.
A DAEMON is a system related background process which requests services like printer daemon requesting printing instructions .

  PID : process id
  PPID : Parent PID

TTY : (command tty)
    terminal = tty = text input/output environment
    Teletypewriter originally and now also means any terminal on Linux/Unix systems. It also means any serial port on Unix/Linux systems.
    ps aux | grep tty

PTS :
    Stands for pseudo terminal slave.
    A pts is the slave part of a pty.
    A pty (pseudo terminal device) is a terminal device which is emulated by an other program (example: xterm, screen, or ssh are such programs).
    /dev/pts contains entries corresponding to devices. /dev/pts is a special directory that is created dynamically by the Linux kernel. The contents of the directory vary with time and reflect the state of the running system.

In laymen terms the primary difference between TTY and PTS is the type of connection to the computer.
TTY ports are direct connections to the computer such as a keyboard/mouse or a serial connection to the device.
PTS connections are SSH connections or telnet connections. All of these connections can connect to a shell which will allow you to issue commands to the computer.


FILES IN UNIX :
---------------
In Unix, there are three basic types of files −

Ordinary Files − An ordinary file is a file on the system that contains data, text, or program instructions.
                 In this tutorial, you look at working with ordinary files.

Directories − Directories store both special and ordinary files.
              For users familiar with Windows or Mac OS, Unix directories are equivalent to folders.

Special Files − Some special files provide access to hardware such as hard drives, CD-ROM drives, modems, and Ethernet adapters.
                Other special files are similar to aliases or shortcuts and enable you to access a single file using different names.
                These are located in /dev (device folder)




STANDARD UNIX STREAMS :
------------------------
stdin  − This is referred to as the standard input and the associated file descriptor is 0. This is also represented as STDIN.
         The Unix program will read the default input from STDIN.
stdout − This is referred to as the standard output and the associated file descriptor is 1. This is also represented as STDOUT.
         The Unix program will write the default output at STDOUT
stderr − This is referred to as the standard error and the associated file descriptor is 2. This is also represented as STDERR.
         The Unix program will write all the error messages at STDERR.


Output Redirection :
--------------------
1. ">"  : To redirect output of a command to a file as in    -> "ls -lrt > file" .
          If the file doesn't exist it is created automatically .
          Old data if any is lost .
2. ">>" : Similar to ">" redirection but the data is appended rather than over riding .   -> "ls -lrt >> file"
          The data is written to end of file and old data stays as it is .
3. "<"  : To take input from a file instead of keyboard   -> "cat < file"


VARIABLES IN LINUX : (they are case -sensitive)
--------------------
1) System variables - Created and maintained by Linux itself. This type of variable defined in CAPITAL CASE LETTERS.
2) User defined variables - Created and maintained by user. This type of variable defined in LOWER CASE LETTERS.
You can see system variables by giving command like $ set. Just type in "set" command .
Also we can print them using " $ echo $USERNAME ".

$ set -> prints all variables
$ set dileep=1994 -> No spaces before after = .
$ echo dileep -> prints "dileep" , use $dileep instead .
$ echo $dileep -> 1994


EXECUTING A SHELL SCRIPT: (#!/usr/bin/env bash) -> the code for all commands is available in /bin folder .
some commands are shell-built_in like cd , others are written as programs in /bin . To check , execute "which <command>"
https://swcarpentry.github.io/shell-novice/06-script/index.html
-------------------------
1. write a file file.sh with the required code

2. You can execute it as "bash file.sh" or "sh file.sh" or "/bin/sh file.sh"
        sh filename.sh means to execute the file using the system’s basic default shell. Many years ago, that meant the Bourne shell, but in the POSIX era, the Bourne shell was eliminated and the much more powerful Korn shell, ksh, was given sh as a link (alias). But the Korn shell was new enough that it had not lost its copyright and required a fee, Bourne Again Shell, bash, and Z Shell, zsh, were developed as free substitutes.
        bash filename.sh is just naming bash directly. If you have some other shell installed as sh, you can do this to ensure that you’ll get bash and nothing else.

3. Alternatively , you can give the file executable permissions and execute it as "./file.sh" . (chmod +x file.sh)
       ./filename.sh means to execute the file on the shell you are using now, whatever it is. It will run it in whichever shell is invoked by the shebang (#!) line at the beginning of the script . Also helps OS by saying that file is in current directory and hence need not search for files available in  PATH variable .

4. We can even rename "file.sh" to just "file" to give it more of an elite look, and because bash honestly doesn't care what you name your files or what extensions you give it
        Then you can execute directly as "./file"

5. We can remove "./", by moving file into a directory that's part of the bash environment's executable PATH .
        Then you can execute simply by doing "file"


==> To execute a linux command, do "$(command)" as in $echo "current dir is $(pwd)"
    Also you can use `date`. As in -> echo " today is `date` " .


$ echo 3 + 5 -> prints 3 + 5
$ expr 3+5   -> prints 3+5 , use spaces .
$ expr 3 + 5 -> 8
$ echo "Todays date is `date`"  -> Todays date is TUE NOV 24 16:17:12 IST 2020
$ echo `expr 3 + 5`    -> 8
$ echo ` 2 + 3`   -> error

COMMAND LINE ARGUMENTS : https://www.grymoire.com/Unix/Quote.html
------------------------
Consider a command : myfile foo bar
Here $# will be 2 (Since foo and bar only two Arguments), Please note At a time such 9 arguments can be used from $0..$9.
You can also refer all of them by using $* (which expand to `$0,$1,$2...$9`).

echo "Total number of command line argument are $#"
echo "$0 is script name"
echo "$1 is first argument"
echo $2 is second argument"
echo "All of them are :- $*"

-> bash file.sh 1 2 3 4 5
$# = 5 ; $* = 1 2 3 4 5
-> ./file.sh 1 2 3 4 5
$# = 5 ; $* = 1 2 3 4 5

######################################################

# Select lines from the middle of a file.
# Usage: bash middle.sh filename end_line num_lines
head -n "$2" "$1" | tail -n "$3"
(or)
wc -l "$@" | sort -n    -> if we have more than 1 file to process .


EXIT STATUS : ($?)
-------------
By default in Linux if particular command is executed, it return two type of values, (Values are used to see whether command is successful or not)
if return value is zero (0), command is successful,
if return value is nonzero (>0), command is not successful
or some sort of error executing command/shell script.
This value is know as Exit Status of that command. To determine this exit Status we use $? variable of shell.

if - then - fi  :
---------------------

if cat $1
then
 echo -e "\n\nFile $1, found and successfully echoed"
fi

if test $1 -gt 0
then
 echo "$1 number is positive"
fi


For Mathematical Operators :

-eq ======== is equal to ======== (5 == 6) ======== if test 5 -eq 6 ======== if expr [ 5 -eq 6 ]
-ne ======== is not equal to ======== 5 != 6 ======== if test 5 -ne 6  ======== if expr [ 5 -ne 6 ]
-lt ======== is less than ======== 5 < 6 ======== if test 5 -lt 6 ======== if expr [ 5 -lt 6 ]
-le ======== is less than or equal to ======== 5 <= 6 ======== if test 5 -le 6 ======== if expr [ 5 -le 6 ]
-gt ======== is greater than ======== 5 > 6 ======== if test 5 -gt 6 ======== if expr [ 5 -gt 6 ]
-ge ======== is greater than or equal to ======== 5 >= 6 ======== if test 5 -ge 6 ======== if expr [ 5 -ge 6 ]

For string Comparisons use :

string1 = string2              string1 is equal to string2
string1 != string2             string1 is NOT equal to string2
string1                        string1 is NOT NULL or not defined
-n string1                     string1 is NOT NULL and does exist
-z string1                     string1 is NULL and does exist

Shell also test for file and directory types :

-s file                        Non empty file
-f file                        Is File exist or normal file and not a directory
-d dir                         Is Directory exist and not a file
-w file                        Is writeable file
-r file                        Is read-only file
-x file                        Is file is executable

if - then - else - fi  :
---------------------
# Script to see whether argument is positive or negative
if [ $# -eq 0 ]
then
 echo "$0 : You must give/supply one integers"
 exit 1
fi
if test $1 -gt 0
then
 echo "$1 number is positive"
else
 echo "$1 number is negative"
fi


if - elif - else - fi  :
----------------------------
# Script to test if..elif...else
if [ $1 -gt 0 ]
then
  echo "$1 is positive"
elif [ $1 -lt 0 ]
then
    echo "$1 is negative"
elif [ $1 -eq 0 ]
then
  echo "$1 is zero"
else
  echo "Opps! $1 is not number, give number"
fi

for loop :
----------
for { variable name } in { list }
do
 execute one for each item in the list until the list is
 not finished (And repeat all statement between do and done)
done

for i in 1 2 3 4 5
do
 echo "Welcome $i times"
done

n=$1
for i in 1 2 3 4 5 6 7 8 9 10
do
 echo "$n * $i = `expr $i \* $n`"
done

while loop :
------------
n=$1
i=1
while [ $i -le 10 ]
do
 echo "$n * $i = `expr $i \* $n`"
 i=`expr $i + 1`
done

CASE statement :
----------------
