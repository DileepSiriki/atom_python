
KERNAL :

Kernel is hart of Linux O/S. It manages resource of Linux O/S. Resources means facilities available in Linux.
For eg. Facility to store data, print data on printer, memory, file management etc . Kernel decides who will use this resource, for how long and when. 
It runs your programs (or set up to execute binary files) It's Memory resident portion of Linux. It performance following task :-
● I/O management
● Process management
● Device management
● File management
● Memory management

SHELL : ( a macro processor that executes commands)

In computing, a shell is a computer program which exposes an operating system's services to a human user or other program .
In general, operating system shells use either a command-line interface (CLI) or graphical user interface (GUI), depending on a computer's role and particular operation
It is named a shell because it is the outermost layer around the operating system.
A command-line interface (CLI) is an operating system shell that uses alphanumeric characters typed on a keyboard to provide instructions and data to the operating system.
Including various services to their users, including file management, process management (running and terminating applications), batch processing, and operating system monitoring and configuration.
MICROSOFT WINDOWS -> Windows Shell and Power shell
LINUX/UNIX  -> Bourne again Shell (bash) , unix shell , Bourne shell (sh)


UNINX SHELL : 

A Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts.[
A Unix shell is both a command interpreter and a programming language. 
As a command interpreter, the shell provides the user interface to the rich set of gnu utilities. The programming language features allow these utilities to be combined
Unix shells provide filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration.

Computer understand the language of 0's and 1's called binary language,
In early days of computing, instruction are provided using binary language, which is difficult for all of us, to read and write. 
So in O/s there is special program called Shell. Shell accepts your instruction or commands in English and translate it into computers native binary language.

  command/shell_script -> Linux shell -> Binary equalent of command -> KERNAL 
  $ls ; $date -> BASH -> 10001101 -> LINUX KERNAL 
  
  OS = KERNAL + SHELL [KERNAL handles everything and shell helps us interact with it .]
  

SHELL SCRIPTING :	(called BATCH files in MS-DOS)

A shell script is a computer program designed to be run by the Unix shell, a command-line interpreter
The biggest advantage of writing a shell script is that the commands and syntax are exactly the same as those directly entered at the command-line. The programmer does not have to switch to a totally different syntax, as they would if the script were written in a different language, or if a compiled language were used.
Disadvantages -> rm -rf */ and rm -rf * / (deletes everything including root ) and also that commands vary by  a single wod -> cd cc df etc;

======================================

1. help :  a. command --help  -> help is a bash built-in, providing help for bash commands only. 
           b. man command    -> A little less descriptive than info but straight to point .
           c. info command   -> describe all about the command in detail. Its like lots and lots of pages of information will be there for a single command.
                            
2. more -> When the text passed to it is too large to fit on one screen, it pages it. You can scroll down but not up.
           press enter or spacebar to navigate and q to exit.
           more /path/to/logile.txt
           more -10 /path/.. to set numberof lines a page should contain
           more +10 /path/... to start from a specific line (here 10)
           cat /path/to/logfilr.txt | more
           ls --help | more
           
3. less -> you can scroll both up and down .
          less /path/... -> now enter /<string> to highlight the string needed.
          less -N -> display line numbers (not available in more )
          The main difference between more and less is that less command is faster because it does not load the entire file at once and allows navigation though file using page up/down keys

4. cat  -> textfile.txt 
           cat > textfile.txt -> opens a file to write content . press ctrl+D to save and exit 
                              -> if you do it to an already existing file , prevous contents will be deleted .
           cat textfile.txt -> opens a file 
           
5. echo  ->  echo <string> -> display string on screen
             echo $var -> display value of variable if any
             echo <text> > textfile ->remove old contents in textfile and write <text> to it .
             echo <text> >> textfile -> append <text> to the textfile .
             echo * is is similar to ls command 
             
INODE :  https://helpdeskgeek.com/linux-tips/what-are-inodes-in-linux-and-how-are-they-used/
An inode is a data structure that stores various information about a file in Linux, such as the access mode (read, write, execute permissions), ownership, file type, file size, group, number of links, etc. Each inode is identified by an integer number. An inode is assigned to a file when it is created .

6. ls ->    List files with colour schemes (blue to folders , black to files etc;)
            ls -R -> Recursive list , to list files even inside a directory .
            ls -a || la --all -> list files starting with a "."
            ls -l -> use vertical listing
            ls -i -> show the inodes 
            ls -s -> print size allocated
            ls -S -> sort by size and print
            ls by default sorts by name , do "ls --sort=word -opt"
            ls -l | sort and ls -l | sort -r to sort in reverse 
                        
            ls -al -> detailed list of files and permissions , storage etc;
            drwxr-xr-x                      7               esrkdlp           rnd             4096         Jun 11  2019       workspace
            [filetype-permissions] - [# od hardlinks] - [Owner-Creator] - [Owber-group] - [Size in bytes] - [Date-Time] - [Name of file/dir]
            " - " -> file
            " d " -> directory
  
 
7. cd -> Chnage to a directory

8. pwd -> Present working directory

9. mkdir -> Make a directory
            mkdir abc     -> create a dir in current directory
            mkdir /test/abc     -> create a directory in /test directory 
            mkdir dir1 dir2 dir3 -> create multiple directories at a time 
            rmdir abc     -> removes a directory
            

10. cp -> cp stands for copy. This command is used to copy files or group of files or directory. It creates an exact image of a file on a disk with different file             name. copies each source file to the destination directory with the same name, created if not existed but if already existed then it will be overwritten,           so be careful !!.
          cp Src_file Dest_file
          cp Src_file1 Src_file2 Src_file3 Dest_directory  
              (For this case last argument must be a directory name. For the above command to work, Dest_directory must exist because cp command won’t create it.)
          cp -R Src_directory Dest_directory
              (cp behavior depend upon whether Dest_directory is exist or not.
              If the Dest_directory doesn’t exist, cp creates it and copies content of Src_directory recursively as it is. 
              But if Dest_directory exists then copy of Src_directory becomes sub-directory under Dest_directory)
          cp -i -> interactive (asks confirmation)
          cp -f -> forcbly copy
          cp -b -> create a backup of destination  before copying 
          cp -n -> To not overwrite an existing filr 
          
          IF [-i -n -f] ALL THREE ARGUMENTS ARE PRESENT , THE FINAL OPTIONS TAKES PRESIDENCE.
          
11. mv -> mv stands for move. mv is used to move one or more files or directories from one place to another in file system like UNIX. It has two distinct functions:
          - It rename a file or folder/directory .
          - It moves group of files to different directory.
          If the destination file doesn’t exist, it will be created. 
          If the destination file exist, then it will be overwrite and the source file will be deleted. By default, mv doesn’t prompt for overwriting So be careful 
          SIMILAR OPTIONS TO cp COMMAND.
          
12. ln ->
        HARD/SOFT links : https://ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/
        A symbolic or soft link is an actual link to the original file, whereas a hard link is a mirror copy of the original file. If you delete the original file,         the soft link has no value, because it points to a non-existent file. But in the case of hard link, it is entirely opposite. Even if you delete the original         file, the hard link will still has the data of the original file. Because hard link acts as a mirror copy of the original file. A link in UNIX is a pointer         to a file. Creating links is a kind of shortcuts to access a file. Links allow more than one file name to refer to the same file, elsewhere.
        
        There are two types of links  :
         1. Soft Link or Symbolic links -> Symbolic links are not updated (they merely contain a string which is the pathname of its target)
                $ ln  [original filename] [link name] 
                  can cross the file system,
                  allows you to link between directories,
                  has different inode number and file permissions than original file,
                  permissions will not be updated,
                  has only the path of the original file, not the contents.
                
         2. Hard Links -> hard links always refer to the source, even if moved or removed
                $ ln  -s [original filename] [link name]
                  can't cross the file system boundaries (i.e. A hardlink can only work on the same filesystem),
                  can't link directories,
                  has the same inode number and permissions of original file,
                  permissions will be updated if we change the permissions of source file,
     
        esekilxv8818 [15:15] [/home/esrkdlp] -> mkdir links
        esekilxv8818 [15:15] [/home/esrkdlp] -> cd links
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> echo "sample text" > abc.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls
        abc.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ln -s abc.txt efg.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls
        abc.txt  efg.txt
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> cat abc.txt 
        sample text
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> cat efg.txt 
        sample text
        esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls -lia
        total 16
        2990710331 drwxr-xr-x  2 esrkdlp rnd  4096 Nov 19 15:16 .
        3028884948 drwxr-xr-x 74 esrkdlp rnd 12288 Nov 19 15:15 ..
        2990710332 -rw-r--r--  1 esrkdlp rnd    12 Nov 19 15:16 abc.txt
        2990710333 lrwxrwxrwx  1 esrkdlp rnd     7 Nov 19 15:16 efg.txt -> abc.txt
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> rm abc 
        abc.txt  efg.txt@ 
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> rm abc.txt 
        rm: remove regular file `abc.txt'? y
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> ls
        efg.txt
        esekilxv8818 [15:17] [/home/esrkdlp/links] -> cat efg.txt 
        cat: efg.txt: No such file or directory
      
Do a similar steps for hardlinks checking.If you copy a file, it will just duplicate the content. So if you modify the content of a one file (either original or hard link), it has no effect on the other one. However if you create a hard link to a file and change the content of either of the files, the change will be be seen on both.
           
13. sort -> SORT command is used to sort a file, arranging the records in a particular order.
            Lines starting with a number will appear before lines starting with a letter.
            Lines starting with a letter that appears earlier in the alphabet will appear before lines starting with a letter that appears later in the alphabet.
            Lines starting with a lowercase letter will appear before lines starting with the same letter in uppercase.
            sort abc.txt
            sort -o abc.txt def.txt ->send the output to destination def.txt
            sort -r abc.txt -> sort in reverse order
            sort -c abc.txt -> check if file is sorted
            sort -u abc.txt -> sort and remoce duplicates 
            sort -n abc.txt -> numerical sort
            sort -k xn abc.txt -> sort using the column number x (useful for tables)


14. rm ->  rm stands for remove here. rm command is used to remove objects such as files, directories, symbolic links and so on from the file system like UNIX. To be more precise, rm removes references to objects from the filesystem, where those objects might have had multiple references (for example, a file with two different names). By default, it does not remove directories.

            rm file1 file2 
            rm -i file -> interactive remove
            rm -f file -> forece remove
            rm -r file -> recursive remove
            rm -rf dir -> recursive remove directory

15. chmod ->  chmod {u|g|o|a} {+|-|=} {r|w|x} {filename} 
                  drwxr-xr-x  -> [type][(owner)(group)(others)]
                  WHO   ###    u -> User who owns the file ; g -> Group file owner  ;  o -> User classified as other ;  a -> All of above (u+g+o)
                  WHAT  ###    + -> Set permission         ; - -> Remove permission ;  = -> set and remove others 
                  WHICH ###    r -> Read permission        ; w -> Write permission  ;  x -> Execute permission
                  
                  0: (000) No permission.
                  1: (001) Execute permission.
                  2: (010) Write permission.
                  3: (011) Write and execute permissions.
                  4: (100) Read permission.
                  5: (101) Read and execute permissions.
                  6: (110) Read and write permissions.
                  7: (111) Read, write, and execute permissions.
             
              1. chmod u=rw,og=r new_file.txt (wipe out previous and set)
              2. chmod a+x new_script.sh  (add an extra. a+x is similar to +x )
              3. chmod -R o-r *.page (for subdirectories and files ending in .page)
              4. chmod 664 *.page
              
16. sudo ->  You only need root/sudo privileges, only if the command involves files or directories not owned by the user or group running the commands
             By default, the password you entered for sudo is retained for 15 minutes per terminal. This eliminates the need of entering the password time and again
             Sudo program allows regular users to run programs with the security privileges of the superuser or root.
             Sudo maintains a log of each command run. System administrators can trackback the person responsible for undesirable changes in the system.
             
17. history ->  To fetch the history of typed in commands 
18. clear   ->  Clears the screen and gives a clean window .
19. apt-get ->  In Linux/UNIX, installation files are distributed as packages. But the package contains only the program itself. 
                Any dependent components will have to be installed separately which are usually available as packages themselves.
                sudo apt-get update -> update all packages installed in our system.
20. 

              
            
              
 
 
        
        
        
        
        
        
        

             

